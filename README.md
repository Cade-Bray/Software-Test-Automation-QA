# Software Test, Automation QA
  This course, CS-320, was with Southern New Hampshire University. The intent of this repository is to show skills that I've advanced in Software Testing, Quality Assurance, and Testing Automation. The primary tool utlized throughout this course was JUnit testing. This tool allows for unit testing in Java. IntelliJ IDEA annotations were used in conjunction for clarity. The paper shown in this repository demonstrates fundemental knowledge of testing methodology and the Software Testing Life Cycle.

## Ensuring my code, program, or software is functional and secure
  To ensure that my code, program, or software is functional and secure I need to adhere to rigorous testing frameworks and methodology. This might include functional or non-functional testing. Functional testing includes unit testing, intergration testing, system testing, and user acceptance testing (UAT). Unit testing is foundational in ensuring functionality and security by ensuring proper line coverage throught project files. Without proper coverage untested code could be released to an end-user resulting in undesirable and unsecure outcomes. Intergration testing ensures each individual method, class, and overarching systems mesh together to form an expected outcome. System testing can be related to inspecting a pipeline for leaks. While intergration testing focuses on individual components coming together; system testing focuses on the entirity of the system for points of failure. Finally UAT is taking an abstracted view of the system and changing your perspective to that of an end user. Asking questions such as "Does this product meet the needs of the user?" is one of many undertaken. Non-functional testing might include performance testing, security testing, and usability testing. Time matters not just to product owners but end users as well. Perforamnce testing goes to seek out statistics on products and identifying points of inefficiency. Security testing protects your users and product owners from malicious actors. These tests might include testing unauthorized user access, injection testing, and other security concerns.

## Interpretting user needs and incorporate them into a program
  Interpretation of user needs starts with the source. Gathering user stories and performing research is crucial to understand no matter who you are in an engineering team. These user stories are concentrated into product requirements and documented. There is often a disconnect when it comes to translating product requirements into testable metrics. It starts with understanding which of your product requirements are functional and non-functional testing metrics. Each of these features functional or not require acceptance criteria to be established. This might include statements such as "As a user I want to upload my profile picture" and what series of steps need to be taken to achieve this goal. These steps are individually unit tested if functional. These tests need to include a 'Happy path' and a 'sad path' which can be elaborated to be expected and unexpected input values and output values/conditions.

## Approaching Software Design
  Appraching software design as a software testing engineer and as a software engineer requires keeping a security and testing at the forefront of your mind at all times. Many software engineers are eager to start writing code but quickly build technical debit because they lacked focus on what inclusive functionality was desired. Start with defining the needs and building the tests to accept a product before designing modules that accomplish those goals. These concepts are frequantly discussed in the software testing life cycle. 
